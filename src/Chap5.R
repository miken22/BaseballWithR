# Work following the examples provided in Chapter 5
# Written by Mike Nowicki

require(curl)
require(data.table)
require(dplyr)
require(chron)
require(pacman)
require(plyr)
require(ggplot2)
require(retrosheet)
require(pitchRx)
require(Lahman)

# Plot of run differentials
game_data2015 <- getRetrosheet("game", 2015)
total_runs <- c(game_data2015$VisRuns, game_data2015$HmRuns)
qplot(tor_runs, geom="density")


team_ids <- getTeamIDs(2015)
# Ensure the csv file is in R's working directory before running this
pbpdata2015 <- read.csv("all_data.csv", header = FALSE)
# Fields csv has been reduced to the 36 common fields generated by BEVENT
fields <- read.csv("fields.csv")
names(pbpdata2015) <- fields[,"Header"]
#head(pbpdata2015)

pbpdata2015$RUNS <- with(pbpdata2015, AWAY_SCORE_CT + HOME_SCORE_CT)
pbpdata2015$HALF_INNING <- with(pbpdata2015, paste(GAME_ID, INN_CT, BATTING_TM))

pbpdata2015$RUNS_SCORED <- with(pbpdata2015, (BAT_DEST_ID > 3) + (RUN1_DEST_ID > 3) + (RUN2_DEST_ID > 3) + (RUN3_DEST_ID > 3))
RUNS_SCORED_INNING <- aggregate(pbpdata2015$RUNS_SCORED, list(HALF_INNING=pbpdata2015$HALF_INNING), sum)
RUNS_SCORED_START <- aggregate(pbpdata2015$RUNS, list(HALF_INNING=pbpdata2015$HALF_INNING), "[",1)

MAX <- data.frame(HALF_INNING = RUNS_SCORED_START$HALF_INNING)
MAX$x <- RUNS_SCORED_INNING$x + RUNS_SCORED_START$x

pbpdata2015 <- merge(pbpdata2015, MAX)
N <- ncol(pbpdata2015)
names(pbpdata2015)[N] <- "MAX_RUNS"

pbpdata2015$RUNS_ROI <- with(pbpdata2015, MAX_RUNS - RUNS)
RUNNER1 <- ifelse (as.character(pbpdata2015[,"BASE1_RUN_ID"]) == "", 0, 1)
RUNNER2 <- ifelse (as.character(pbpdata2015[,"BASE2_RUN_ID"]) == "", 0, 1)
RUNNER3 <- ifelse (as.character(pbpdata2015[,"BASE3_RUN_ID"]) == "", 0, 1)

get.state <- function(runner1, runner2, runner3, outs) {
  runners <- paste(runner1, runner2, runner3, sep="")
  paste(runners, outs)
}
pbpdata2015$STATE <- get.state(RUNNER1, RUNNER2, RUNNER3, pbpdata2015$OUTS_CT)

NRUNNER1 <- with(pbpdata2015, as.numeric(RUN1_DEST_ID == 1 | BAT_DEST_ID == 1))
NRUNNER2 <- with(pbpdata2015, as.numeric(RUN1_DEST_ID == 2 | RUN2_DEST_ID == 2 | BAT_DEST_ID == 2))
NRUNNER3 <- with(pbpdata2015, as.numeric(RUN1_DEST_ID == 3 | RUN2_DEST_ID == 3 | RUN3_DEST_ID == 3 | BAT_DEST_ID == 3))
NOUTS <- with(pbpdata2015, OUTS_CT + EVENT_OUTS_CT)
pbpdata2015$NEW_STATE <- get.state(NRUNNER1, NRUNNER2, NRUNNER3, NOUTS)

pbpdata2015 <- subset(pbpdata2015, (STATE != NEW_STATE) | RUNS_SCORED > 0)

# Adjust for partial half innings
data.outs <- ddply(pbpdata2015, .(HALF_INNING), summarize, Outs.Inning=sum(EVENT_OUTS_CT))
pbpdata2015 <- merge(pbpdata2015, data.outs)
pbpdata2015C <- subset(pbpdata2015, Outs.Inning == 3)

RUNS <- with(pbpdata2015C, aggregate(RUNS_ROI, list(STATE), mean))

RUNS$Outs <- substr(RUNS$Group, 5, 5)
RUNS <- RUNS[order(RUNS$Outs),]
# Creates the run expectancy matrix
RUNS.out <- matrix(round(RUNS$x, 2), 8, 3)
dimnames(RUNS.out)[[2]] <- c("0 Outs", "1 Out", "2 Outs")
dimnames(RUNS.out)[[1]] <- c("000", "001", "010", "011", "100", "101", "110", "111")