# Chapter 8
# By Michael Nowicki

require(curl)
require(data.table)
require(dplyr)
require(chron)
require(plyr)
require(ggplot2)
require(retrosheet)
require(pitchRx)
require(Lahman)

#############################################################
## Recycled from Chapter 5 to create the run data for 2015.##
#############################################################

team_ids <- getTeamIDs(2015)
# Ensure the csv file is in R's working directory before running this
pbpdata2015 <- read.csv("data/all_data.csv", header = FALSE)
# Fields csv has been reduced to the 36 common fields generated by BEVENT
fields <- read.csv("data/fields.csv")
names(pbpdata2015) <- fields[,"Header"]

pbpdata2015$RUNS <- with(pbpdata2015, AWAY_SCORE_CT + HOME_SCORE_CT)
pbpdata2015$HALF_INNING <- with(pbpdata2015, paste(GAME_ID, INN_CT, BATTING_TM))

pbpdata2015$RUNS_SCORED <- with(pbpdata2015, (BAT_DEST_ID > 3) + (RUN1_DEST_ID > 3) + (RUN2_DEST_ID > 3) + (RUN3_DEST_ID > 3))
RUNS_SCORED_INNING <- aggregate(pbpdata2015$RUNS_SCORED, list(HALF_INNING=pbpdata2015$HALF_INNING), sum)
RUNS_SCORED_START <- aggregate(pbpdata2015$RUNS, list(HALF_INNING=pbpdata2015$HALF_INNING), "[",1)

MAX <- data.frame(HALF_INNING = RUNS_SCORED_START$HALF_INNING)
MAX$x <- RUNS_SCORED_INNING$x + RUNS_SCORED_START$x

pbpdata2015 <- merge(pbpdata2015, MAX)
N <- ncol(pbpdata2015)
names(pbpdata2015)[N] <- "MAX_RUNS"

pbpdata2015$RUNS_ROI <- with(pbpdata2015, MAX_RUNS - RUNS)
RUNNER1 <- ifelse (as.character(pbpdata2015[,"BASE1_RUN_ID"]) == "", 0, 1)
RUNNER2 <- ifelse (as.character(pbpdata2015[,"BASE2_RUN_ID"]) == "", 0, 1)
RUNNER3 <- ifelse (as.character(pbpdata2015[,"BASE3_RUN_ID"]) == "", 0, 1)

get.state <- function(runner1, runner2, runner3, outs) {
  runners <- paste(runner1, runner2, runner3, sep="")
  paste(runners, outs)
}
pbpdata2015$STATE <- get.state(RUNNER1, RUNNER2, RUNNER3, pbpdata2015$OUTS_CT)

NRUNNER1 <- with(pbpdata2015, as.numeric(RUN1_DEST_ID == 1 | BAT_DEST_ID == 1))
NRUNNER2 <- with(pbpdata2015, as.numeric(RUN1_DEST_ID == 2 | RUN2_DEST_ID == 2 | BAT_DEST_ID == 2))
NRUNNER3 <- with(pbpdata2015, as.numeric(RUN1_DEST_ID == 3 | RUN2_DEST_ID == 3 | RUN3_DEST_ID == 3 | BAT_DEST_ID == 3))
NOUTS <- with(pbpdata2015, OUTS_CT + EVENT_OUTS_CT)
pbpdata2015$NEW_STATE <- get.state(NRUNNER1, NRUNNER2, NRUNNER3, NOUTS)

library(plyr)
data.outs <- ddply(pbpdata2015, .(HALF_INNING), summarize, Outs.Inning=sum(EVENT_OUTS_CT))
pbpdata2015 <- merge(pbpdata2015, data.outs)
pbpdata2015C <- subset(pbpdata2015, Outs.Inning == 3)

pbpdata2015C <- subset(pbpdata2015, BAT_EVENT_FL == TRUE)

library(car)
pbpdata2015C$NEW_STATE <- recode(pbpdata2015C$NEW_STATE, "c('000 3', '100 3', '010 3', '001 3',
                                 '110 3', '101 3', '011 3', '111 3')='3'")

T.matrix <- with(pbpdata2015C, table(STATE, NEW_STATE))
P.matrix <- prop.table(T.matrix, 1)
P.matrix <- rbind(P.matrix, c(rep(0,24), 1))

P1 <- round(P.matrix["000 0", ], 3)
data.frame(Prob=P1[P1 > 0])

P2 <- round(P.matrix["010 2", ], 3)

count.runners.out <- function(s)
  sum(as.numeric(strsplit(s,"")[[1]]), na.rm = TRUE)

runners.outs <- sapply(dimnames(T.matrix)[[1]], count.runners.out)[-25]
R <- outer(runners.outs + 1, runners.outs, FUN = "-")
dimnames(R)[[1]] <- dimnames(T.matrix)[[1]][-25]
dimnames(R)[[2]] <- dimnames(T.matrix)[[1]][-25]
R <- cbind(R, rep(0, 24))

simulate.half.inning <- function(P, R, start=1) {
  s <- start; path <- NULL; runs <- 0;
  while(s < 25) {
    s.new <- sample(1:25, 1, prob = P[s, ])
    path <- c(path, s.new)
    runs <- runs + R[s, s.new]
    s <- s.new
  }
  runs
}

RUNS <- replicate(10000, simulate.half.inning(T.matrix, R))

sum(count(RUNS[RUNS >= 5])[2]) / 10000
mean(RUNS)

RUNS.j <- function(j) {
  mean(replicate(10000, simulate.half.inning(T.matrix, R, j)))
}

Runs.Expectancy <- sapply(1:24, RUNS.j)
Runs.Expectancy <- t(round(matrix(Runs.Expectancy, 3, 8), 2))
dimnames(Runs.Expectancy)[[2]] <- c("0 Outs", "1 Out", "2 Outs")
dimnames(Runs.Expectancy)[[1]] <- c("000", "001", "010", "011", "100", "101", "110", "111")
